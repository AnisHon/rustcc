use num_derive::FromPrimitive;

#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, FromPrimitive)]
pub enum TokenType {
    {%- for item in enums -%}
        {{ item }},
    {% endfor %}
}

const STATE_MAP: [Option<TokenType>; {{ state_map_size }}] = [
    {%- for item in state_map -%}
        {%- if item %}Some(TokenType::{{ item }}){%- else %}None{%- endif -%},
    {%- endfor -%}
];

const CHAR_CLASS: [(u32, u32); {{ char_class_size }}] = [
    {%- for item in char_class -%}({{ item[0] }}, {{ item[1] }}),{%- endfor -%}
];

const CHAR_CLASS_MAP: [usize; {{ char_class_size }}] = [
    {%- for item in char_class_map -%}{{ item }},{%- endfor -%}
];

const ASCII_MAPPING: [usize; 128] = [
    {%- for item in ascii_map -%}{{ item }},{%- endfor -%}
];

const BASE: [Option<usize>; {{ state_map_size }}] = {{ base }};

const NEXT: [usize; {{ next_size }}] = [
    {%- for item in next -%}{{ item }},{%- endfor -%}
];

const CHECK: [Option<usize>; {{ next_size }}] = {{ check }};

const ROW_ID: [usize; {{ row_id | length }}] = [
    {%- for item in row_id -%}{{ item }},{%- endfor -%}
];

pub const INIT_STATE: usize = {{ init_state }};

pub fn find_token(state_id: usize) -> Option<TokenType> {
    STATE_MAP[state_id]
}

pub fn find_next(state_id: usize, chr: char) -> Option<usize> {
    let row_id = ROW_ID[state_id];
    let class_id = find_char(chr);
    let base = BASE[row_id];
    if base.is_none() {
        return None
    }

    let idx = base.unwrap() + class_id;
    let check = CHECK[idx];
    if check.is_none() {
        return None
    }


    if check.unwrap() == row_id {
        Some(NEXT[idx])
    } else {
        None
    }
}

fn find_char(chr: char) -> usize {
    let idx = find_idx(chr);
    CHAR_CLASS_MAP[idx]
}

fn find_idx(chr: char) -> usize {
    if chr.is_ascii() {
        // 快速路径
        ASCII_MAPPING[chr as usize]
    } else {
        // 慢路径
        binary_search(chr as u32) // 出错会触发panic
    }
}

/// 二分查找
fn binary_search(chr: u32) -> usize {
    let ranges = &CHAR_CLASS;
    let mut idx_left = 0;
    let mut idx_right = ranges.len() - 1; // 左闭右闭

    while idx_left <= idx_right {
        let idx_mid = (idx_left + idx_right) / 2;
        let (l, r) = ranges[idx_mid];

        if l <= chr && chr <= r {
            return idx_mid;
        }

        if l < chr {
            idx_left = idx_mid + 1;
        } else {
            idx_right = idx_mid - 1;
        }
    }

    // 在我的设计下，会有一个覆盖全集的大范围，不会出现这种情况
    panic!("Not Find {}", chr)
}




