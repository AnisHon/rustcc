use std::mem;
{{ user_code }}

#[derive(Debug, Clone)]
pub enum LRAction {
    Reduce(usize), // 规约 推导式ID
    Shift(usize),  // 移入 状态ID
    Accept(usize),    // 结束规约 推导式ID
    Error          // 出错Error
}

#[allow(clippy::large_array_const)]
// action matrix -> base next check
const ACTION_BASE: [Option<usize>; {{ action_base | length }}] = [
    {%- for item in action_base -%}{{ item }},{%- endfor -%}
];

#[allow(clippy::large_array_const)]
const ACTION_NEXT: [LRAction; {{ action_next | length }}] = [
    {%- for item in action_next -%}LRAction::{{ item }},{%- endfor -%}
];

#[allow(clippy::large_array_const)]
const ACTION_CHECK: [Option<usize>; {{ action_check | length }}] = [
    {%- for item in action_check -%}{{ item }},{%- endfor -%}
];

#[allow(clippy::large_array_const)]
const ACTION_ROW_ID: [usize; {{ action_row_id | length }}] = [
    {%- for item in action_row_id -%}{{ item }},{%- endfor -%}
];

// goto matrix -> base next check
#[allow(clippy::large_array_const)]
const GOTO_BASE: [Option<usize>; {{ goto_base | length }}] = [
    {%- for item in goto_base -%}{{ item }},{%- endfor -%}
];

#[allow(clippy::large_array_const)]
const GOTO_NEXT: [Option<usize>; {{ goto_next | length }}] = [
    {%- for item in goto_next -%}{{ item }},{%- endfor -%}
];

#[allow(clippy::large_array_const)]
const GOTO_CHECK: [Option<usize>; {{ goto_check | length }}] = [
    {%- for item in goto_check -%}{{ item }},{%- endfor -%}
];

#[allow(clippy::large_array_const)]
const GOTO_ROW_ID: [usize; {{ goto_row_id | length }}] = [
    {%- for item in goto_row_id -%}{{ item }},{%- endfor -%}
];


// prod_id -> length for reduce
pub const EXPR_LENS: [usize; {{ expr_lens | length }}] = [
    {%- for item in expr_lens -%}{{ item }},{%- endfor -%}
];

// prod_id -> expr name(non-terminal name)
pub const EXPR_NAMES: [&str; {{ expr_names | length }}] = [
    {%- for item in expr_names -%}"{{ item }}",{%- endfor -%}
];

// prod_id -> rule id(non-terminal name)
const EXPR_IDS: [usize; {{ expr_ids | length }}] = [
    {%- for item in expr_ids -%}{{ item }},{%- endfor -%}
];

// token_id -> token content (terminal name)
pub const TOKEN_CONTENTS: [&str; {{ token_contents | length }}] = [
    {%- for item in token_contents -%}"{{ item }}",{%- endfor -%}
];

pub const INIT_STATE: usize = {{ init_state }};
pub const END_SYMBOL: usize = {{ end_symbol }};

/// action_table[state][token]
pub fn get_action(state: usize, token: usize) -> LRAction {
    let row_id = ACTION_ROW_ID[state];
    let base = ACTION_BASE[row_id];
    if base.is_none() {
        return LRAction::Error
    }

    let idx = base.unwrap() + token;

    let check = ACTION_CHECK[idx]?;

    if check == row_id {
        ACTION_NEXT[idx].clone()
    } else {
        LRAction::Error
    }
}

/// action_table[state][EXPR_IDS[prod_id]]
pub fn get_goto(state: usize, prod_id: usize) -> Option<usize> {
    let row_id = GOTO_ROW_ID[state];
    let rule_id = EXPR_IDS[prod_id];
    let base = GOTO_BASE[row_id]?;

    let idx = base.unwrap() + rule_id;

    let check = GOTO_CHECK[idx]?;

    if check == row_id {
        GOTO_NEXT[idx]
    } else {
        None
    }
}

/// action_code[state](params)
pub fn exec_action(rule: usize, mut {{ vs_name }}: Vec<{{ typename }}>) -> {{ typename }} {
    let {{ cv_name }}: {{ typename }};
    match rule {
        {%- for item in action_codes -%}
            {% if item %}
                {{ loop.index0 }} => {{ item }},
            {% endif %}
        {%- endfor -%}
        _ => { {{ cv_name }} = {{ typename }}::default() }
    };
    {{ cv_name }}
}

