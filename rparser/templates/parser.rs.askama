#![allow(clippy::useless_conversion)]
use LRAction::*;
{{ decl_code }}


/// vector deconstruct into vars
macro_rules! destruct_vec {
    ($vec:expr, $($var:ident),*) => {
        let [$($var),*] = $vec.try_into().expect("destruct failed");
    };
}

pub const INIT_STATE: usize = {{ init_state }};
pub const END_SYMBOL: usize = {{ end_symbol }};

/// LR Table Cell Type
#[derive(Debug, Clone)]
pub enum LRAction {
    Reduce(usize),
    Shift(usize),
    Accept(usize),
    Error
}


/// action matrix -> base next check
static ACTION_BASE: [Option<usize>; {{ action_base_sz }}] = {{ action_base }};

static ACTION_NEXT: [LRAction; {{ action_next_sz }}] = {{ action_next }};

static ACTION_CHECK: [Option<usize>; {{ action_check_sz }}] = {{ action_check }};

static ACTION_ROW_ID: [usize; {{ action_row_id_sz }}] = {{ action_row_id }};


/// goto matrix -> base next check
static GOTO_BASE: [Option<usize>; {{ goto_base_sz }}] = {{ goto_base }};

static GOTO_NEXT: [Option<usize>; {{ goto_next_sz }}] = {{ goto_next }};

static GOTO_CHECK: [Option<usize>; {{ goto_check_sz }}] = {{ goto_check }};

static GOTO_ROW_ID: [usize; {{ goto_row_id_sz }}] = {{ goto_row_id }};


/// prod_id -> length for reduce
pub static EXPR_LENS: [usize; {{ expr_lens_sz }}] = {{ expr_lens }};

/// prod_id -> expr name(non-terminal name)
pub static EXPR_NAMES: [&str; {{ expr_names_sz }}] = {{ expr_names }};

/// prod_id -> rule id(non-terminal name)
static EXPR_IDS: [usize; {{ expr_ids_sz }}] = {{ expr_ids }};

/// token_id -> token content (terminal name)
pub static TOKEN_CONTENTS: [Option<&str>; {{ token_contents_sz }}] = {{ token_contents }};


{%- macro parameter() -%}
    _arguments: Vec<{{ typename }}>,{%- for item in params %} {{ item }},{%- endfor -%}
{%- endmacro -%}

type ActionHandler = fn({%- call parameter() -%}) -> {{ typename }};

pub static ACTION_CODES: [Option<ActionHandler>;{{ action_codes.len() }}] = [
{%- for item in action_codes %}
    {%- match item -%}
        {%- when Some(code) %}
    Some(|{%- call parameter() -%}| {     // {{ loop.index0 }}
        let value;
        {%- if !arguments[loop.index0].is_empty() %}
        destruct_vec!(_arguments, {{ arguments[loop.index0] }});
        {%- endif %}
        {{ code }}
        value
    }),
        {%- when none %}
    None,
   {%- endmatch -%}
{%- endfor %}
];



/// action_table[state][token]
pub fn get_action(state: usize, token: usize) -> LRAction {
    let row_id = ACTION_ROW_ID[state];
    let base = ACTION_BASE[row_id];
    if base.is_none() {
        return Error
    }

    let idx = base.unwrap() + token;

    let check = match ACTION_CHECK[idx] {
        None => return Error,
        Some(x) => x
    };

    if check == row_id {
        ACTION_NEXT[idx].clone()
    } else {
        Error
    }
}

/// action_table[state][EXPR_IDS[prod_id]]
pub fn get_goto(state: usize, prod_id: usize) -> Option<usize> {
    let row_id = GOTO_ROW_ID[state];
    let rule_id = EXPR_IDS[prod_id];
    let base = GOTO_BASE[row_id]?;

    let idx = base + rule_id;

    let check = GOTO_CHECK[idx]?;

    if check == row_id {
        GOTO_NEXT[idx]
    } else {
        None
    }
}


{{ user_code }}